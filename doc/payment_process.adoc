= Payment process

== Links

* https://stripe.com/blog/european-payment-methods-available-worldwide
* https://stripe.com/docs/payments/older-apis#comparing-the-apis
* https://stripe.com/docs/payments/payment-intents/migration/charges
* https://stripe.com/gb/guides/strong-customer-authentication

== Browser workflow

=== Current payment methoud through Charges API

==== Retrieve token for payment

See: link:https://stripe.com/docs/api/tokens[Tokens]

[source]
----
POST https://api.stripe.com/v1/tokens
----

Request (link:https://stripe.com/docs/api/tokens/create_card[Create a card token])
[source]
----
card[name]=<name>&
card[address_line1]=<address&
card[address_line2]=&
card[address_city]=Munich&
card[address_state]=WV&
card[address_zip]=80000&
card[address_country]=US&
card[currency]=USD&
card[number]=1234567887654321&
card[cvc]=123&
card[exp_month]=12&
card[exp_year]=22&
guid=762c71c6-faea-44fd-aedd-e8678678686785caea&
muid=90d08257-feff-4ff0-8a26-56f56756756726d521&
sid=7725a954-faea-4fee-9347-123454353024534534&
payment_user_agent=stripe.js%2F54555345e%3B+stripe-js-v3%2F45345696e&
time_on_page=79343&
key=pk_live_C94n1iS49jH7gpBEkMhDbxVb00xdC0jaBm
----

Response (link:https://stripe.com/docs/api/tokens/object[The token object])

[source]
----
{
  "id": "tok_2LasdfgasdfasdfasfasdfZX0",
  "object": "token",
  "card": {
    "id": "card_adfasdfasdfasdfsadfN",
    "object": "card",
    "address_city": "Munich",
    "address_country": "US",
    "address_line1": "<address>",
    "address_line1_check": "unchecked",
    "address_line2": "",
    "address_state": "WV",
    "address_zip": "80000",
    "address_zip_check": "unchecked",
    "brand": "MasterCard",
    "country": "DE",
    "currency": "usd",
    "cvc_check": "unchecked",
    "dynamic_last4": null,
    "exp_month": 12,
    "exp_year": 2022,
    "funding": "credit",
    "last4": "4321",
    "name": "<name>",
    "tokenization_method": null
  },
  "client_ip": "109.43.50.188",
  "created": 1662129312,
  "livemode": true,
  "type": "card",
  "used": false
}
----

==== Execute payment through payment server

POST https://payments.private.storage/v1/stripe/charge

----
{
  "voucher" : "AWaYIHqjuCOlDjOV4VMLR_czbir3FeUapizTrZ50YwQj",
  "checksum" : "3fdc6253206337f4b2082489c9dfa66687121d3016fdd52b346ead9525571cc5",
  "token" : "tok_2LasdfgasdfasdfasfasdfZX0",
  "currency" : "USD",
  "amount" : "650"
}
----

Response

----
{"success":true}
----

==== Migration

In order to allow Strong Customer Authentication (SCA) we need to migrate to use the Payment Intents (see link:https://stripe.com/docs/payments/payment-intents/migration[Payment intents migration]) or use the.

This changes the way the transaction is managed:


|===
|Step |using Charges |using Payment intents

|1. Register intent
|n/a
|`POST /v1/payment_intents`

|2. Collect payment details on client
|`stripe.createToken(cardElement)`
|`stripe.confirmCardPayment(secret, cardElement)`

|3. Initiate create of the payment
|`POST /v1/charges`
|n/a
|===

Currently the PaymentServer handles the call triggering the payments in a synchronous way and will receive the success/failed information directly. Follow up action can be executed in place after a successful payment.

In the new workflow the PaymentServer will need to create a Payment intent using the Stripe client secret and return it to the Browser. and store it with some reference to the customer in order to not lose payments when the Browser is killed between authorizing the payment and notifying the backend about the success.
This is because the actual payment is triggered from browser interactions referencing the Payment intent (This allows to use additional security features as the Browser interacts directly with the Stripe API).

After the Stripe interaction is done, we need to poll Stripe with the reference to the Payment intent in order to check if the payment has been successful.

We assume that we need to store the created intents somewhere in the backend, to avoid that customers are losing payments when the process is interrupted. That may add much more complexity, because that state needs to be stored and managed.

[plantuml, target=diagram-classes, format=png]
....
participant Browser as browser
participant PaymentService as service
participant Stripe as backend

browser -> service : Create Payment intent
service -> backend : Create Payment intent
backend -> service : Payment intent
service -> browser : Payment intent

alt Error: Payment already exists

browser -> service : Get Payment intent
service -> backend : Get Payment intent
backend -> service : Either[Payment intent]
service -> browser : Payment intent

end

alt No Payment found

browser -> backend : Execute stripe.confirmCardPayment(...)
backend -> browser : Success/Failure

end
....

Open topics
* it seems to be possible to store metadata when creating the payment intent. We could use this to store the `voucher_id` with the payment in order to retrieve an interupted payment information later on:
+

----
curl https://api.stripe.com/v1/payment_intents \
  -u sk_test_Y17KokhC3SRYCQTLYiU5ZCD2: \
  -d "amount"=1099 \
  -d "currency"="usd" \
  -d "payment_method_types[]"="card" \
  -d "metadata[voucher_id]"="234234234"
----